// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: demo.proto

#ifndef PROTOBUF_demo_2eproto__INCLUDED
#define PROTOBUF_demo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace demo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_demo_2eproto();
void protobuf_AssignDesc_demo_2eproto();
void protobuf_ShutdownFile_demo_2eproto();

class VarintMsg;
class Bit64;
class Bit32;
class LenPayload;

enum AuctionType {
  FIRST_PRICE = 1,
  SECOND_PRICE = 2,
  FIXED_PRICE = 3
};
bool AuctionType_IsValid(int value);
const AuctionType AuctionType_MIN = FIRST_PRICE;
const AuctionType AuctionType_MAX = FIXED_PRICE;
const int AuctionType_ARRAYSIZE = AuctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuctionType_descriptor();
inline const ::std::string& AuctionType_Name(AuctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuctionType_descriptor(), value);
}
inline bool AuctionType_Parse(
    const ::std::string& name, AuctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuctionType>(
    AuctionType_descriptor(), name, value);
}
// ===================================================================

class VarintMsg : public ::google::protobuf::Message {
 public:
  VarintMsg();
  virtual ~VarintMsg();

  VarintMsg(const VarintMsg& from);

  inline VarintMsg& operator=(const VarintMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarintMsg& default_instance();

  void Swap(VarintMsg* other);

  // implements Message ----------------------------------------------

  VarintMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarintMsg& from);
  void MergeFrom(const VarintMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 argI32 = 1;
  inline bool has_argi32() const;
  inline void clear_argi32();
  static const int kArgI32FieldNumber = 1;
  inline ::google::protobuf::int32 argi32() const;
  inline void set_argi32(::google::protobuf::int32 value);

  // required int64 argI64 = 2;
  inline bool has_argi64() const;
  inline void clear_argi64();
  static const int kArgI64FieldNumber = 2;
  inline ::google::protobuf::int64 argi64() const;
  inline void set_argi64(::google::protobuf::int64 value);

  // required uint32 argUI32 = 3;
  inline bool has_argui32() const;
  inline void clear_argui32();
  static const int kArgUI32FieldNumber = 3;
  inline ::google::protobuf::uint32 argui32() const;
  inline void set_argui32(::google::protobuf::uint32 value);

  // required uint64 argUI64 = 4;
  inline bool has_argui64() const;
  inline void clear_argui64();
  static const int kArgUI64FieldNumber = 4;
  inline ::google::protobuf::uint64 argui64() const;
  inline void set_argui64(::google::protobuf::uint64 value);

  // required sint32 argSI32 = 5;
  inline bool has_argsi32() const;
  inline void clear_argsi32();
  static const int kArgSI32FieldNumber = 5;
  inline ::google::protobuf::int32 argsi32() const;
  inline void set_argsi32(::google::protobuf::int32 value);

  // required sint64 argSI64 = 6;
  inline bool has_argsi64() const;
  inline void clear_argsi64();
  static const int kArgSI64FieldNumber = 6;
  inline ::google::protobuf::int64 argsi64() const;
  inline void set_argsi64(::google::protobuf::int64 value);

  // repeated bool argBool = 7;
  inline int argbool_size() const;
  inline void clear_argbool();
  static const int kArgBoolFieldNumber = 7;
  inline bool argbool(int index) const;
  inline void set_argbool(int index, bool value);
  inline void add_argbool(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      argbool() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_argbool();

  // optional .demo.AuctionType argEnum = 8;
  inline bool has_argenum() const;
  inline void clear_argenum();
  static const int kArgEnumFieldNumber = 8;
  inline ::demo::AuctionType argenum() const;
  inline void set_argenum(::demo::AuctionType value);

  // @@protoc_insertion_point(class_scope:demo.VarintMsg)
 private:
  inline void set_has_argi32();
  inline void clear_has_argi32();
  inline void set_has_argi64();
  inline void clear_has_argi64();
  inline void set_has_argui32();
  inline void clear_has_argui32();
  inline void set_has_argui64();
  inline void clear_has_argui64();
  inline void set_has_argsi32();
  inline void clear_has_argsi32();
  inline void set_has_argsi64();
  inline void clear_has_argsi64();
  inline void set_has_argenum();
  inline void clear_has_argenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 argi64_;
  ::google::protobuf::int32 argi32_;
  ::google::protobuf::uint32 argui32_;
  ::google::protobuf::uint64 argui64_;
  ::google::protobuf::int64 argsi64_;
  ::google::protobuf::int32 argsi32_;
  int argenum_;
  ::google::protobuf::RepeatedField< bool > argbool_;
  friend void  protobuf_AddDesc_demo_2eproto();
  friend void protobuf_AssignDesc_demo_2eproto();
  friend void protobuf_ShutdownFile_demo_2eproto();

  void InitAsDefaultInstance();
  static VarintMsg* default_instance_;
};
// -------------------------------------------------------------------

class Bit64 : public ::google::protobuf::Message {
 public:
  Bit64();
  virtual ~Bit64();

  Bit64(const Bit64& from);

  inline Bit64& operator=(const Bit64& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bit64& default_instance();

  void Swap(Bit64* other);

  // implements Message ----------------------------------------------

  Bit64* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bit64& from);
  void MergeFrom(const Bit64& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 argFixed64 = 1;
  inline bool has_argfixed64() const;
  inline void clear_argfixed64();
  static const int kArgFixed64FieldNumber = 1;
  inline ::google::protobuf::uint64 argfixed64() const;
  inline void set_argfixed64(::google::protobuf::uint64 value);

  // required sfixed64 argSFixed64 = 2;
  inline bool has_argsfixed64() const;
  inline void clear_argsfixed64();
  static const int kArgSFixed64FieldNumber = 2;
  inline ::google::protobuf::int64 argsfixed64() const;
  inline void set_argsfixed64(::google::protobuf::int64 value);

  // required double argDouble = 3;
  inline bool has_argdouble() const;
  inline void clear_argdouble();
  static const int kArgDoubleFieldNumber = 3;
  inline double argdouble() const;
  inline void set_argdouble(double value);

  // @@protoc_insertion_point(class_scope:demo.Bit64)
 private:
  inline void set_has_argfixed64();
  inline void clear_has_argfixed64();
  inline void set_has_argsfixed64();
  inline void clear_has_argsfixed64();
  inline void set_has_argdouble();
  inline void clear_has_argdouble();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 argfixed64_;
  ::google::protobuf::int64 argsfixed64_;
  double argdouble_;
  friend void  protobuf_AddDesc_demo_2eproto();
  friend void protobuf_AssignDesc_demo_2eproto();
  friend void protobuf_ShutdownFile_demo_2eproto();

  void InitAsDefaultInstance();
  static Bit64* default_instance_;
};
// -------------------------------------------------------------------

class Bit32 : public ::google::protobuf::Message {
 public:
  Bit32();
  virtual ~Bit32();

  Bit32(const Bit32& from);

  inline Bit32& operator=(const Bit32& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bit32& default_instance();

  void Swap(Bit32* other);

  // implements Message ----------------------------------------------

  Bit32* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bit32& from);
  void MergeFrom(const Bit32& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 argFixed32 = 1;
  inline bool has_argfixed32() const;
  inline void clear_argfixed32();
  static const int kArgFixed32FieldNumber = 1;
  inline ::google::protobuf::uint32 argfixed32() const;
  inline void set_argfixed32(::google::protobuf::uint32 value);

  // required sfixed32 argSFixed32 = 2;
  inline bool has_argsfixed32() const;
  inline void clear_argsfixed32();
  static const int kArgSFixed32FieldNumber = 2;
  inline ::google::protobuf::int32 argsfixed32() const;
  inline void set_argsfixed32(::google::protobuf::int32 value);

  // required float argFloat = 3;
  inline bool has_argfloat() const;
  inline void clear_argfloat();
  static const int kArgFloatFieldNumber = 3;
  inline float argfloat() const;
  inline void set_argfloat(float value);

  // @@protoc_insertion_point(class_scope:demo.Bit32)
 private:
  inline void set_has_argfixed32();
  inline void clear_has_argfixed32();
  inline void set_has_argsfixed32();
  inline void clear_has_argsfixed32();
  inline void set_has_argfloat();
  inline void clear_has_argfloat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 argfixed32_;
  ::google::protobuf::int32 argsfixed32_;
  float argfloat_;
  friend void  protobuf_AddDesc_demo_2eproto();
  friend void protobuf_AssignDesc_demo_2eproto();
  friend void protobuf_ShutdownFile_demo_2eproto();

  void InitAsDefaultInstance();
  static Bit32* default_instance_;
};
// -------------------------------------------------------------------

class LenPayload : public ::google::protobuf::Message {
 public:
  LenPayload();
  virtual ~LenPayload();

  LenPayload(const LenPayload& from);

  inline LenPayload& operator=(const LenPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LenPayload& default_instance();

  void Swap(LenPayload* other);

  // implements Message ----------------------------------------------

  LenPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LenPayload& from);
  void MergeFrom(const LenPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string argStrList = 1;
  inline int argstrlist_size() const;
  inline void clear_argstrlist();
  static const int kArgStrListFieldNumber = 1;
  inline const ::std::string& argstrlist(int index) const;
  inline ::std::string* mutable_argstrlist(int index);
  inline void set_argstrlist(int index, const ::std::string& value);
  inline void set_argstrlist(int index, const char* value);
  inline void set_argstrlist(int index, const char* value, size_t size);
  inline ::std::string* add_argstrlist();
  inline void add_argstrlist(const ::std::string& value);
  inline void add_argstrlist(const char* value);
  inline void add_argstrlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& argstrlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argstrlist();

  // optional .demo.VarintMsg argVarintMsg = 2;
  inline bool has_argvarintmsg() const;
  inline void clear_argvarintmsg();
  static const int kArgVarintMsgFieldNumber = 2;
  inline const ::demo::VarintMsg& argvarintmsg() const;
  inline ::demo::VarintMsg* mutable_argvarintmsg();
  inline ::demo::VarintMsg* release_argvarintmsg();
  inline void set_allocated_argvarintmsg(::demo::VarintMsg* argvarintmsg);

  // optional .demo.Bit64 argBit64 = 3;
  inline bool has_argbit64() const;
  inline void clear_argbit64();
  static const int kArgBit64FieldNumber = 3;
  inline const ::demo::Bit64& argbit64() const;
  inline ::demo::Bit64* mutable_argbit64();
  inline ::demo::Bit64* release_argbit64();
  inline void set_allocated_argbit64(::demo::Bit64* argbit64);

  // optional .demo.Bit32 argBit32 = 4;
  inline bool has_argbit32() const;
  inline void clear_argbit32();
  static const int kArgBit32FieldNumber = 4;
  inline const ::demo::Bit32& argbit32() const;
  inline ::demo::Bit32* mutable_argbit32();
  inline ::demo::Bit32* release_argbit32();
  inline void set_allocated_argbit32(::demo::Bit32* argbit32);

  // @@protoc_insertion_point(class_scope:demo.LenPayload)
 private:
  inline void set_has_argvarintmsg();
  inline void clear_has_argvarintmsg();
  inline void set_has_argbit64();
  inline void clear_has_argbit64();
  inline void set_has_argbit32();
  inline void clear_has_argbit32();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argstrlist_;
  ::demo::VarintMsg* argvarintmsg_;
  ::demo::Bit64* argbit64_;
  ::demo::Bit32* argbit32_;
  friend void  protobuf_AddDesc_demo_2eproto();
  friend void protobuf_AssignDesc_demo_2eproto();
  friend void protobuf_ShutdownFile_demo_2eproto();

  void InitAsDefaultInstance();
  static LenPayload* default_instance_;
};
// ===================================================================


// ===================================================================

// VarintMsg

// required int32 argI32 = 1;
inline bool VarintMsg::has_argi32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarintMsg::set_has_argi32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarintMsg::clear_has_argi32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarintMsg::clear_argi32() {
  argi32_ = 0;
  clear_has_argi32();
}
inline ::google::protobuf::int32 VarintMsg::argi32() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argI32)
  return argi32_;
}
inline void VarintMsg::set_argi32(::google::protobuf::int32 value) {
  set_has_argi32();
  argi32_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argI32)
}

// required int64 argI64 = 2;
inline bool VarintMsg::has_argi64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarintMsg::set_has_argi64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarintMsg::clear_has_argi64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarintMsg::clear_argi64() {
  argi64_ = GOOGLE_LONGLONG(0);
  clear_has_argi64();
}
inline ::google::protobuf::int64 VarintMsg::argi64() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argI64)
  return argi64_;
}
inline void VarintMsg::set_argi64(::google::protobuf::int64 value) {
  set_has_argi64();
  argi64_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argI64)
}

// required uint32 argUI32 = 3;
inline bool VarintMsg::has_argui32() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarintMsg::set_has_argui32() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarintMsg::clear_has_argui32() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarintMsg::clear_argui32() {
  argui32_ = 0u;
  clear_has_argui32();
}
inline ::google::protobuf::uint32 VarintMsg::argui32() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argUI32)
  return argui32_;
}
inline void VarintMsg::set_argui32(::google::protobuf::uint32 value) {
  set_has_argui32();
  argui32_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argUI32)
}

// required uint64 argUI64 = 4;
inline bool VarintMsg::has_argui64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VarintMsg::set_has_argui64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VarintMsg::clear_has_argui64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VarintMsg::clear_argui64() {
  argui64_ = GOOGLE_ULONGLONG(0);
  clear_has_argui64();
}
inline ::google::protobuf::uint64 VarintMsg::argui64() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argUI64)
  return argui64_;
}
inline void VarintMsg::set_argui64(::google::protobuf::uint64 value) {
  set_has_argui64();
  argui64_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argUI64)
}

// required sint32 argSI32 = 5;
inline bool VarintMsg::has_argsi32() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VarintMsg::set_has_argsi32() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VarintMsg::clear_has_argsi32() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VarintMsg::clear_argsi32() {
  argsi32_ = 0;
  clear_has_argsi32();
}
inline ::google::protobuf::int32 VarintMsg::argsi32() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argSI32)
  return argsi32_;
}
inline void VarintMsg::set_argsi32(::google::protobuf::int32 value) {
  set_has_argsi32();
  argsi32_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argSI32)
}

// required sint64 argSI64 = 6;
inline bool VarintMsg::has_argsi64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VarintMsg::set_has_argsi64() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VarintMsg::clear_has_argsi64() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VarintMsg::clear_argsi64() {
  argsi64_ = GOOGLE_LONGLONG(0);
  clear_has_argsi64();
}
inline ::google::protobuf::int64 VarintMsg::argsi64() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argSI64)
  return argsi64_;
}
inline void VarintMsg::set_argsi64(::google::protobuf::int64 value) {
  set_has_argsi64();
  argsi64_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argSI64)
}

// repeated bool argBool = 7;
inline int VarintMsg::argbool_size() const {
  return argbool_.size();
}
inline void VarintMsg::clear_argbool() {
  argbool_.Clear();
}
inline bool VarintMsg::argbool(int index) const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argBool)
  return argbool_.Get(index);
}
inline void VarintMsg::set_argbool(int index, bool value) {
  argbool_.Set(index, value);
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argBool)
}
inline void VarintMsg::add_argbool(bool value) {
  argbool_.Add(value);
  // @@protoc_insertion_point(field_add:demo.VarintMsg.argBool)
}
inline const ::google::protobuf::RepeatedField< bool >&
VarintMsg::argbool() const {
  // @@protoc_insertion_point(field_list:demo.VarintMsg.argBool)
  return argbool_;
}
inline ::google::protobuf::RepeatedField< bool >*
VarintMsg::mutable_argbool() {
  // @@protoc_insertion_point(field_mutable_list:demo.VarintMsg.argBool)
  return &argbool_;
}

// optional .demo.AuctionType argEnum = 8;
inline bool VarintMsg::has_argenum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VarintMsg::set_has_argenum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VarintMsg::clear_has_argenum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VarintMsg::clear_argenum() {
  argenum_ = 1;
  clear_has_argenum();
}
inline ::demo::AuctionType VarintMsg::argenum() const {
  // @@protoc_insertion_point(field_get:demo.VarintMsg.argEnum)
  return static_cast< ::demo::AuctionType >(argenum_);
}
inline void VarintMsg::set_argenum(::demo::AuctionType value) {
  assert(::demo::AuctionType_IsValid(value));
  set_has_argenum();
  argenum_ = value;
  // @@protoc_insertion_point(field_set:demo.VarintMsg.argEnum)
}

// -------------------------------------------------------------------

// Bit64

// required fixed64 argFixed64 = 1;
inline bool Bit64::has_argfixed64() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bit64::set_has_argfixed64() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bit64::clear_has_argfixed64() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bit64::clear_argfixed64() {
  argfixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_argfixed64();
}
inline ::google::protobuf::uint64 Bit64::argfixed64() const {
  // @@protoc_insertion_point(field_get:demo.Bit64.argFixed64)
  return argfixed64_;
}
inline void Bit64::set_argfixed64(::google::protobuf::uint64 value) {
  set_has_argfixed64();
  argfixed64_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit64.argFixed64)
}

// required sfixed64 argSFixed64 = 2;
inline bool Bit64::has_argsfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bit64::set_has_argsfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bit64::clear_has_argsfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bit64::clear_argsfixed64() {
  argsfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_argsfixed64();
}
inline ::google::protobuf::int64 Bit64::argsfixed64() const {
  // @@protoc_insertion_point(field_get:demo.Bit64.argSFixed64)
  return argsfixed64_;
}
inline void Bit64::set_argsfixed64(::google::protobuf::int64 value) {
  set_has_argsfixed64();
  argsfixed64_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit64.argSFixed64)
}

// required double argDouble = 3;
inline bool Bit64::has_argdouble() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bit64::set_has_argdouble() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bit64::clear_has_argdouble() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bit64::clear_argdouble() {
  argdouble_ = 0;
  clear_has_argdouble();
}
inline double Bit64::argdouble() const {
  // @@protoc_insertion_point(field_get:demo.Bit64.argDouble)
  return argdouble_;
}
inline void Bit64::set_argdouble(double value) {
  set_has_argdouble();
  argdouble_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit64.argDouble)
}

// -------------------------------------------------------------------

// Bit32

// required fixed32 argFixed32 = 1;
inline bool Bit32::has_argfixed32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bit32::set_has_argfixed32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bit32::clear_has_argfixed32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bit32::clear_argfixed32() {
  argfixed32_ = 0u;
  clear_has_argfixed32();
}
inline ::google::protobuf::uint32 Bit32::argfixed32() const {
  // @@protoc_insertion_point(field_get:demo.Bit32.argFixed32)
  return argfixed32_;
}
inline void Bit32::set_argfixed32(::google::protobuf::uint32 value) {
  set_has_argfixed32();
  argfixed32_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit32.argFixed32)
}

// required sfixed32 argSFixed32 = 2;
inline bool Bit32::has_argsfixed32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bit32::set_has_argsfixed32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bit32::clear_has_argsfixed32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bit32::clear_argsfixed32() {
  argsfixed32_ = 0;
  clear_has_argsfixed32();
}
inline ::google::protobuf::int32 Bit32::argsfixed32() const {
  // @@protoc_insertion_point(field_get:demo.Bit32.argSFixed32)
  return argsfixed32_;
}
inline void Bit32::set_argsfixed32(::google::protobuf::int32 value) {
  set_has_argsfixed32();
  argsfixed32_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit32.argSFixed32)
}

// required float argFloat = 3;
inline bool Bit32::has_argfloat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bit32::set_has_argfloat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bit32::clear_has_argfloat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bit32::clear_argfloat() {
  argfloat_ = 0;
  clear_has_argfloat();
}
inline float Bit32::argfloat() const {
  // @@protoc_insertion_point(field_get:demo.Bit32.argFloat)
  return argfloat_;
}
inline void Bit32::set_argfloat(float value) {
  set_has_argfloat();
  argfloat_ = value;
  // @@protoc_insertion_point(field_set:demo.Bit32.argFloat)
}

// -------------------------------------------------------------------

// LenPayload

// repeated string argStrList = 1;
inline int LenPayload::argstrlist_size() const {
  return argstrlist_.size();
}
inline void LenPayload::clear_argstrlist() {
  argstrlist_.Clear();
}
inline const ::std::string& LenPayload::argstrlist(int index) const {
  // @@protoc_insertion_point(field_get:demo.LenPayload.argStrList)
  return argstrlist_.Get(index);
}
inline ::std::string* LenPayload::mutable_argstrlist(int index) {
  // @@protoc_insertion_point(field_mutable:demo.LenPayload.argStrList)
  return argstrlist_.Mutable(index);
}
inline void LenPayload::set_argstrlist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:demo.LenPayload.argStrList)
  argstrlist_.Mutable(index)->assign(value);
}
inline void LenPayload::set_argstrlist(int index, const char* value) {
  argstrlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:demo.LenPayload.argStrList)
}
inline void LenPayload::set_argstrlist(int index, const char* value, size_t size) {
  argstrlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:demo.LenPayload.argStrList)
}
inline ::std::string* LenPayload::add_argstrlist() {
  return argstrlist_.Add();
}
inline void LenPayload::add_argstrlist(const ::std::string& value) {
  argstrlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:demo.LenPayload.argStrList)
}
inline void LenPayload::add_argstrlist(const char* value) {
  argstrlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:demo.LenPayload.argStrList)
}
inline void LenPayload::add_argstrlist(const char* value, size_t size) {
  argstrlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:demo.LenPayload.argStrList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LenPayload::argstrlist() const {
  // @@protoc_insertion_point(field_list:demo.LenPayload.argStrList)
  return argstrlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LenPayload::mutable_argstrlist() {
  // @@protoc_insertion_point(field_mutable_list:demo.LenPayload.argStrList)
  return &argstrlist_;
}

// optional .demo.VarintMsg argVarintMsg = 2;
inline bool LenPayload::has_argvarintmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LenPayload::set_has_argvarintmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LenPayload::clear_has_argvarintmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LenPayload::clear_argvarintmsg() {
  if (argvarintmsg_ != NULL) argvarintmsg_->::demo::VarintMsg::Clear();
  clear_has_argvarintmsg();
}
inline const ::demo::VarintMsg& LenPayload::argvarintmsg() const {
  // @@protoc_insertion_point(field_get:demo.LenPayload.argVarintMsg)
  return argvarintmsg_ != NULL ? *argvarintmsg_ : *default_instance_->argvarintmsg_;
}
inline ::demo::VarintMsg* LenPayload::mutable_argvarintmsg() {
  set_has_argvarintmsg();
  if (argvarintmsg_ == NULL) argvarintmsg_ = new ::demo::VarintMsg;
  // @@protoc_insertion_point(field_mutable:demo.LenPayload.argVarintMsg)
  return argvarintmsg_;
}
inline ::demo::VarintMsg* LenPayload::release_argvarintmsg() {
  clear_has_argvarintmsg();
  ::demo::VarintMsg* temp = argvarintmsg_;
  argvarintmsg_ = NULL;
  return temp;
}
inline void LenPayload::set_allocated_argvarintmsg(::demo::VarintMsg* argvarintmsg) {
  delete argvarintmsg_;
  argvarintmsg_ = argvarintmsg;
  if (argvarintmsg) {
    set_has_argvarintmsg();
  } else {
    clear_has_argvarintmsg();
  }
  // @@protoc_insertion_point(field_set_allocated:demo.LenPayload.argVarintMsg)
}

// optional .demo.Bit64 argBit64 = 3;
inline bool LenPayload::has_argbit64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LenPayload::set_has_argbit64() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LenPayload::clear_has_argbit64() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LenPayload::clear_argbit64() {
  if (argbit64_ != NULL) argbit64_->::demo::Bit64::Clear();
  clear_has_argbit64();
}
inline const ::demo::Bit64& LenPayload::argbit64() const {
  // @@protoc_insertion_point(field_get:demo.LenPayload.argBit64)
  return argbit64_ != NULL ? *argbit64_ : *default_instance_->argbit64_;
}
inline ::demo::Bit64* LenPayload::mutable_argbit64() {
  set_has_argbit64();
  if (argbit64_ == NULL) argbit64_ = new ::demo::Bit64;
  // @@protoc_insertion_point(field_mutable:demo.LenPayload.argBit64)
  return argbit64_;
}
inline ::demo::Bit64* LenPayload::release_argbit64() {
  clear_has_argbit64();
  ::demo::Bit64* temp = argbit64_;
  argbit64_ = NULL;
  return temp;
}
inline void LenPayload::set_allocated_argbit64(::demo::Bit64* argbit64) {
  delete argbit64_;
  argbit64_ = argbit64;
  if (argbit64) {
    set_has_argbit64();
  } else {
    clear_has_argbit64();
  }
  // @@protoc_insertion_point(field_set_allocated:demo.LenPayload.argBit64)
}

// optional .demo.Bit32 argBit32 = 4;
inline bool LenPayload::has_argbit32() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LenPayload::set_has_argbit32() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LenPayload::clear_has_argbit32() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LenPayload::clear_argbit32() {
  if (argbit32_ != NULL) argbit32_->::demo::Bit32::Clear();
  clear_has_argbit32();
}
inline const ::demo::Bit32& LenPayload::argbit32() const {
  // @@protoc_insertion_point(field_get:demo.LenPayload.argBit32)
  return argbit32_ != NULL ? *argbit32_ : *default_instance_->argbit32_;
}
inline ::demo::Bit32* LenPayload::mutable_argbit32() {
  set_has_argbit32();
  if (argbit32_ == NULL) argbit32_ = new ::demo::Bit32;
  // @@protoc_insertion_point(field_mutable:demo.LenPayload.argBit32)
  return argbit32_;
}
inline ::demo::Bit32* LenPayload::release_argbit32() {
  clear_has_argbit32();
  ::demo::Bit32* temp = argbit32_;
  argbit32_ = NULL;
  return temp;
}
inline void LenPayload::set_allocated_argbit32(::demo::Bit32* argbit32) {
  delete argbit32_;
  argbit32_ = argbit32;
  if (argbit32) {
    set_has_argbit32();
  } else {
    clear_has_argbit32();
  }
  // @@protoc_insertion_point(field_set_allocated:demo.LenPayload.argBit32)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace demo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::demo::AuctionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::demo::AuctionType>() {
  return ::demo::AuctionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_demo_2eproto__INCLUDED
