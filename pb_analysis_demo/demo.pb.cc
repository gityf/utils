// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: demo.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "demo.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace demo {

namespace {

const ::google::protobuf::Descriptor* VarintMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VarintMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* Bit64_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Bit64_reflection_ = NULL;
const ::google::protobuf::Descriptor* Bit32_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Bit32_reflection_ = NULL;
const ::google::protobuf::Descriptor* LenPayload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LenPayload_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AuctionType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_demo_2eproto() {
  protobuf_AddDesc_demo_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "demo.proto");
  GOOGLE_CHECK(file != NULL);
  VarintMsg_descriptor_ = file->message_type(0);
  static const int VarintMsg_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argi32_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argi64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argui32_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argui64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argsi32_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argsi64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argbool_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, argenum_),
  };
  VarintMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VarintMsg_descriptor_,
      VarintMsg::default_instance_,
      VarintMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VarintMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VarintMsg));
  Bit64_descriptor_ = file->message_type(1);
  static const int Bit64_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit64, argfixed64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit64, argsfixed64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit64, argdouble_),
  };
  Bit64_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Bit64_descriptor_,
      Bit64::default_instance_,
      Bit64_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit64, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit64, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Bit64));
  Bit32_descriptor_ = file->message_type(2);
  static const int Bit32_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit32, argfixed32_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit32, argsfixed32_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit32, argfloat_),
  };
  Bit32_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Bit32_descriptor_,
      Bit32::default_instance_,
      Bit32_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit32, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bit32, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Bit32));
  LenPayload_descriptor_ = file->message_type(3);
  static const int LenPayload_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, argstrlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, argvarintmsg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, argbit64_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, argbit32_),
  };
  LenPayload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LenPayload_descriptor_,
      LenPayload::default_instance_,
      LenPayload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LenPayload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LenPayload));
  AuctionType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_demo_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VarintMsg_descriptor_, &VarintMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Bit64_descriptor_, &Bit64::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Bit32_descriptor_, &Bit32::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LenPayload_descriptor_, &LenPayload::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_demo_2eproto() {
  delete VarintMsg::default_instance_;
  delete VarintMsg_reflection_;
  delete Bit64::default_instance_;
  delete Bit64_reflection_;
  delete Bit32::default_instance_;
  delete Bit32_reflection_;
  delete LenPayload::default_instance_;
  delete LenPayload_reflection_;
}

void protobuf_AddDesc_demo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\ndemo.proto\022\004demo\"\244\001\n\tVarintMsg\022\016\n\006argI"
    "32\030\001 \002(\005\022\016\n\006argI64\030\002 \002(\003\022\017\n\007argUI32\030\003 \002("
    "\r\022\017\n\007argUI64\030\004 \002(\004\022\017\n\007argSI32\030\005 \002(\021\022\017\n\007a"
    "rgSI64\030\006 \002(\022\022\017\n\007argBool\030\007 \003(\010\022\"\n\007argEnum"
    "\030\010 \001(\0162\021.demo.AuctionType\"C\n\005Bit64\022\022\n\nar"
    "gFixed64\030\001 \002(\006\022\023\n\013argSFixed64\030\002 \002(\020\022\021\n\ta"
    "rgDouble\030\003 \002(\001\"B\n\005Bit32\022\022\n\nargFixed32\030\001 "
    "\002(\007\022\023\n\013argSFixed32\030\002 \002(\017\022\020\n\010argFloat\030\003 \002"
    "(\002\"\205\001\n\nLenPayload\022\022\n\nargStrList\030\001 \003(\t\022%\n"
    "\014argVarintMsg\030\002 \001(\0132\017.demo.VarintMsg\022\035\n\010"
    "argBit64\030\003 \001(\0132\013.demo.Bit64\022\035\n\010argBit32\030"
    "\004 \001(\0132\013.demo.Bit32*A\n\013AuctionType\022\017\n\013FIR"
    "ST_PRICE\020\001\022\020\n\014SECOND_PRICE\020\002\022\017\n\013FIXED_PR"
    "ICE\020\003", 525);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "demo.proto", &protobuf_RegisterTypes);
  VarintMsg::default_instance_ = new VarintMsg();
  Bit64::default_instance_ = new Bit64();
  Bit32::default_instance_ = new Bit32();
  LenPayload::default_instance_ = new LenPayload();
  VarintMsg::default_instance_->InitAsDefaultInstance();
  Bit64::default_instance_->InitAsDefaultInstance();
  Bit32::default_instance_->InitAsDefaultInstance();
  LenPayload::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_demo_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_demo_2eproto {
  StaticDescriptorInitializer_demo_2eproto() {
    protobuf_AddDesc_demo_2eproto();
  }
} static_descriptor_initializer_demo_2eproto_;
const ::google::protobuf::EnumDescriptor* AuctionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AuctionType_descriptor_;
}
bool AuctionType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VarintMsg::kArgI32FieldNumber;
const int VarintMsg::kArgI64FieldNumber;
const int VarintMsg::kArgUI32FieldNumber;
const int VarintMsg::kArgUI64FieldNumber;
const int VarintMsg::kArgSI32FieldNumber;
const int VarintMsg::kArgSI64FieldNumber;
const int VarintMsg::kArgBoolFieldNumber;
const int VarintMsg::kArgEnumFieldNumber;
#endif  // !_MSC_VER

VarintMsg::VarintMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:demo.VarintMsg)
}

void VarintMsg::InitAsDefaultInstance() {
}

VarintMsg::VarintMsg(const VarintMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:demo.VarintMsg)
}

void VarintMsg::SharedCtor() {
  _cached_size_ = 0;
  argi32_ = 0;
  argi64_ = GOOGLE_LONGLONG(0);
  argui32_ = 0u;
  argui64_ = GOOGLE_ULONGLONG(0);
  argsi32_ = 0;
  argsi64_ = GOOGLE_LONGLONG(0);
  argenum_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VarintMsg::~VarintMsg() {
  // @@protoc_insertion_point(destructor:demo.VarintMsg)
  SharedDtor();
}

void VarintMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VarintMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VarintMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VarintMsg_descriptor_;
}

const VarintMsg& VarintMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_demo_2eproto();
  return *default_instance_;
}

VarintMsg* VarintMsg::default_instance_ = NULL;

VarintMsg* VarintMsg::New() const {
  return new VarintMsg;
}

void VarintMsg::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VarintMsg*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 191) {
    ZR_(argi64_, argsi32_);
    argenum_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  argbool_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VarintMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:demo.VarintMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 argI32 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &argi32_)));
          set_has_argi32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_argI64;
        break;
      }

      // required int64 argI64 = 2;
      case 2: {
        if (tag == 16) {
         parse_argI64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &argi64_)));
          set_has_argi64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_argUI32;
        break;
      }

      // required uint32 argUI32 = 3;
      case 3: {
        if (tag == 24) {
         parse_argUI32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &argui32_)));
          set_has_argui32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_argUI64;
        break;
      }

      // required uint64 argUI64 = 4;
      case 4: {
        if (tag == 32) {
         parse_argUI64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &argui64_)));
          set_has_argui64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_argSI32;
        break;
      }

      // required sint32 argSI32 = 5;
      case 5: {
        if (tag == 40) {
         parse_argSI32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &argsi32_)));
          set_has_argsi32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_argSI64;
        break;
      }

      // required sint64 argSI64 = 6;
      case 6: {
        if (tag == 48) {
         parse_argSI64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &argsi64_)));
          set_has_argsi64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_argBool;
        break;
      }

      // repeated bool argBool = 7;
      case 7: {
        if (tag == 56) {
         parse_argBool:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 56, input, this->mutable_argbool())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_argbool())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_argBool;
        if (input->ExpectTag(64)) goto parse_argEnum;
        break;
      }

      // optional .demo.AuctionType argEnum = 8;
      case 8: {
        if (tag == 64) {
         parse_argEnum:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::demo::AuctionType_IsValid(value)) {
            set_argenum(static_cast< ::demo::AuctionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:demo.VarintMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:demo.VarintMsg)
  return false;
#undef DO_
}

void VarintMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:demo.VarintMsg)
  // required int32 argI32 = 1;
  if (has_argi32()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->argi32(), output);
  }

  // required int64 argI64 = 2;
  if (has_argi64()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->argi64(), output);
  }

  // required uint32 argUI32 = 3;
  if (has_argui32()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->argui32(), output);
  }

  // required uint64 argUI64 = 4;
  if (has_argui64()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->argui64(), output);
  }

  // required sint32 argSI32 = 5;
  if (has_argsi32()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->argsi32(), output);
  }

  // required sint64 argSI64 = 6;
  if (has_argsi64()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(6, this->argsi64(), output);
  }

  // repeated bool argBool = 7;
  for (int i = 0; i < this->argbool_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      7, this->argbool(i), output);
  }

  // optional .demo.AuctionType argEnum = 8;
  if (has_argenum()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->argenum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:demo.VarintMsg)
}

::google::protobuf::uint8* VarintMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:demo.VarintMsg)
  // required int32 argI32 = 1;
  if (has_argi32()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->argi32(), target);
  }

  // required int64 argI64 = 2;
  if (has_argi64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->argi64(), target);
  }

  // required uint32 argUI32 = 3;
  if (has_argui32()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->argui32(), target);
  }

  // required uint64 argUI64 = 4;
  if (has_argui64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->argui64(), target);
  }

  // required sint32 argSI32 = 5;
  if (has_argsi32()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->argsi32(), target);
  }

  // required sint64 argSI64 = 6;
  if (has_argsi64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(6, this->argsi64(), target);
  }

  // repeated bool argBool = 7;
  for (int i = 0; i < this->argbool_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(7, this->argbool(i), target);
  }

  // optional .demo.AuctionType argEnum = 8;
  if (has_argenum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->argenum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:demo.VarintMsg)
  return target;
}

int VarintMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 argI32 = 1;
    if (has_argi32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->argi32());
    }

    // required int64 argI64 = 2;
    if (has_argi64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->argi64());
    }

    // required uint32 argUI32 = 3;
    if (has_argui32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->argui32());
    }

    // required uint64 argUI64 = 4;
    if (has_argui64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->argui64());
    }

    // required sint32 argSI32 = 5;
    if (has_argsi32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->argsi32());
    }

    // required sint64 argSI64 = 6;
    if (has_argsi64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->argsi64());
    }

    // optional .demo.AuctionType argEnum = 8;
    if (has_argenum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->argenum());
    }

  }
  // repeated bool argBool = 7;
  {
    int data_size = 0;
    data_size = 1 * this->argbool_size();
    total_size += 1 * this->argbool_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VarintMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VarintMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VarintMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VarintMsg::MergeFrom(const VarintMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  argbool_.MergeFrom(from.argbool_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_argi32()) {
      set_argi32(from.argi32());
    }
    if (from.has_argi64()) {
      set_argi64(from.argi64());
    }
    if (from.has_argui32()) {
      set_argui32(from.argui32());
    }
    if (from.has_argui64()) {
      set_argui64(from.argui64());
    }
    if (from.has_argsi32()) {
      set_argsi32(from.argsi32());
    }
    if (from.has_argsi64()) {
      set_argsi64(from.argsi64());
    }
    if (from.has_argenum()) {
      set_argenum(from.argenum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VarintMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VarintMsg::CopyFrom(const VarintMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VarintMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void VarintMsg::Swap(VarintMsg* other) {
  if (other != this) {
    std::swap(argi32_, other->argi32_);
    std::swap(argi64_, other->argi64_);
    std::swap(argui32_, other->argui32_);
    std::swap(argui64_, other->argui64_);
    std::swap(argsi32_, other->argsi32_);
    std::swap(argsi64_, other->argsi64_);
    argbool_.Swap(&other->argbool_);
    std::swap(argenum_, other->argenum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VarintMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VarintMsg_descriptor_;
  metadata.reflection = VarintMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Bit64::kArgFixed64FieldNumber;
const int Bit64::kArgSFixed64FieldNumber;
const int Bit64::kArgDoubleFieldNumber;
#endif  // !_MSC_VER

Bit64::Bit64()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:demo.Bit64)
}

void Bit64::InitAsDefaultInstance() {
}

Bit64::Bit64(const Bit64& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:demo.Bit64)
}

void Bit64::SharedCtor() {
  _cached_size_ = 0;
  argfixed64_ = GOOGLE_ULONGLONG(0);
  argsfixed64_ = GOOGLE_LONGLONG(0);
  argdouble_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Bit64::~Bit64() {
  // @@protoc_insertion_point(destructor:demo.Bit64)
  SharedDtor();
}

void Bit64::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Bit64::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Bit64::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Bit64_descriptor_;
}

const Bit64& Bit64::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_demo_2eproto();
  return *default_instance_;
}

Bit64* Bit64::default_instance_ = NULL;

Bit64* Bit64::New() const {
  return new Bit64;
}

void Bit64::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Bit64*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(argfixed64_, argdouble_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Bit64::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:demo.Bit64)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed64 argFixed64 = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &argfixed64_)));
          set_has_argfixed64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_argSFixed64;
        break;
      }

      // required sfixed64 argSFixed64 = 2;
      case 2: {
        if (tag == 17) {
         parse_argSFixed64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &argsfixed64_)));
          set_has_argsfixed64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_argDouble;
        break;
      }

      // required double argDouble = 3;
      case 3: {
        if (tag == 25) {
         parse_argDouble:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &argdouble_)));
          set_has_argdouble();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:demo.Bit64)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:demo.Bit64)
  return false;
#undef DO_
}

void Bit64::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:demo.Bit64)
  // required fixed64 argFixed64 = 1;
  if (has_argfixed64()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->argfixed64(), output);
  }

  // required sfixed64 argSFixed64 = 2;
  if (has_argsfixed64()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(2, this->argsfixed64(), output);
  }

  // required double argDouble = 3;
  if (has_argdouble()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->argdouble(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:demo.Bit64)
}

::google::protobuf::uint8* Bit64::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:demo.Bit64)
  // required fixed64 argFixed64 = 1;
  if (has_argfixed64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->argfixed64(), target);
  }

  // required sfixed64 argSFixed64 = 2;
  if (has_argsfixed64()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(2, this->argsfixed64(), target);
  }

  // required double argDouble = 3;
  if (has_argdouble()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->argdouble(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:demo.Bit64)
  return target;
}

int Bit64::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed64 argFixed64 = 1;
    if (has_argfixed64()) {
      total_size += 1 + 8;
    }

    // required sfixed64 argSFixed64 = 2;
    if (has_argsfixed64()) {
      total_size += 1 + 8;
    }

    // required double argDouble = 3;
    if (has_argdouble()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bit64::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Bit64* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Bit64*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Bit64::MergeFrom(const Bit64& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_argfixed64()) {
      set_argfixed64(from.argfixed64());
    }
    if (from.has_argsfixed64()) {
      set_argsfixed64(from.argsfixed64());
    }
    if (from.has_argdouble()) {
      set_argdouble(from.argdouble());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Bit64::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bit64::CopyFrom(const Bit64& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bit64::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Bit64::Swap(Bit64* other) {
  if (other != this) {
    std::swap(argfixed64_, other->argfixed64_);
    std::swap(argsfixed64_, other->argsfixed64_);
    std::swap(argdouble_, other->argdouble_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Bit64::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Bit64_descriptor_;
  metadata.reflection = Bit64_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Bit32::kArgFixed32FieldNumber;
const int Bit32::kArgSFixed32FieldNumber;
const int Bit32::kArgFloatFieldNumber;
#endif  // !_MSC_VER

Bit32::Bit32()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:demo.Bit32)
}

void Bit32::InitAsDefaultInstance() {
}

Bit32::Bit32(const Bit32& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:demo.Bit32)
}

void Bit32::SharedCtor() {
  _cached_size_ = 0;
  argfixed32_ = 0u;
  argsfixed32_ = 0;
  argfloat_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Bit32::~Bit32() {
  // @@protoc_insertion_point(destructor:demo.Bit32)
  SharedDtor();
}

void Bit32::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Bit32::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Bit32::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Bit32_descriptor_;
}

const Bit32& Bit32::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_demo_2eproto();
  return *default_instance_;
}

Bit32* Bit32::default_instance_ = NULL;

Bit32* Bit32::New() const {
  return new Bit32;
}

void Bit32::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Bit32*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(argfixed32_, argfloat_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Bit32::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:demo.Bit32)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 argFixed32 = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &argfixed32_)));
          set_has_argfixed32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_argSFixed32;
        break;
      }

      // required sfixed32 argSFixed32 = 2;
      case 2: {
        if (tag == 21) {
         parse_argSFixed32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &argsfixed32_)));
          set_has_argsfixed32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_argFloat;
        break;
      }

      // required float argFloat = 3;
      case 3: {
        if (tag == 29) {
         parse_argFloat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &argfloat_)));
          set_has_argfloat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:demo.Bit32)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:demo.Bit32)
  return false;
#undef DO_
}

void Bit32::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:demo.Bit32)
  // required fixed32 argFixed32 = 1;
  if (has_argfixed32()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->argfixed32(), output);
  }

  // required sfixed32 argSFixed32 = 2;
  if (has_argsfixed32()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(2, this->argsfixed32(), output);
  }

  // required float argFloat = 3;
  if (has_argfloat()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->argfloat(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:demo.Bit32)
}

::google::protobuf::uint8* Bit32::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:demo.Bit32)
  // required fixed32 argFixed32 = 1;
  if (has_argfixed32()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(1, this->argfixed32(), target);
  }

  // required sfixed32 argSFixed32 = 2;
  if (has_argsfixed32()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed32ToArray(2, this->argsfixed32(), target);
  }

  // required float argFloat = 3;
  if (has_argfloat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->argfloat(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:demo.Bit32)
  return target;
}

int Bit32::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 argFixed32 = 1;
    if (has_argfixed32()) {
      total_size += 1 + 4;
    }

    // required sfixed32 argSFixed32 = 2;
    if (has_argsfixed32()) {
      total_size += 1 + 4;
    }

    // required float argFloat = 3;
    if (has_argfloat()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bit32::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Bit32* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Bit32*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Bit32::MergeFrom(const Bit32& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_argfixed32()) {
      set_argfixed32(from.argfixed32());
    }
    if (from.has_argsfixed32()) {
      set_argsfixed32(from.argsfixed32());
    }
    if (from.has_argfloat()) {
      set_argfloat(from.argfloat());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Bit32::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bit32::CopyFrom(const Bit32& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bit32::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Bit32::Swap(Bit32* other) {
  if (other != this) {
    std::swap(argfixed32_, other->argfixed32_);
    std::swap(argsfixed32_, other->argsfixed32_);
    std::swap(argfloat_, other->argfloat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Bit32::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Bit32_descriptor_;
  metadata.reflection = Bit32_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LenPayload::kArgStrListFieldNumber;
const int LenPayload::kArgVarintMsgFieldNumber;
const int LenPayload::kArgBit64FieldNumber;
const int LenPayload::kArgBit32FieldNumber;
#endif  // !_MSC_VER

LenPayload::LenPayload()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:demo.LenPayload)
}

void LenPayload::InitAsDefaultInstance() {
  argvarintmsg_ = const_cast< ::demo::VarintMsg*>(&::demo::VarintMsg::default_instance());
  argbit64_ = const_cast< ::demo::Bit64*>(&::demo::Bit64::default_instance());
  argbit32_ = const_cast< ::demo::Bit32*>(&::demo::Bit32::default_instance());
}

LenPayload::LenPayload(const LenPayload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:demo.LenPayload)
}

void LenPayload::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  argvarintmsg_ = NULL;
  argbit64_ = NULL;
  argbit32_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LenPayload::~LenPayload() {
  // @@protoc_insertion_point(destructor:demo.LenPayload)
  SharedDtor();
}

void LenPayload::SharedDtor() {
  if (this != default_instance_) {
    delete argvarintmsg_;
    delete argbit64_;
    delete argbit32_;
  }
}

void LenPayload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LenPayload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LenPayload_descriptor_;
}

const LenPayload& LenPayload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_demo_2eproto();
  return *default_instance_;
}

LenPayload* LenPayload::default_instance_ = NULL;

LenPayload* LenPayload::New() const {
  return new LenPayload;
}

void LenPayload::Clear() {
  if (_has_bits_[0 / 32] & 14) {
    if (has_argvarintmsg()) {
      if (argvarintmsg_ != NULL) argvarintmsg_->::demo::VarintMsg::Clear();
    }
    if (has_argbit64()) {
      if (argbit64_ != NULL) argbit64_->::demo::Bit64::Clear();
    }
    if (has_argbit32()) {
      if (argbit32_ != NULL) argbit32_->::demo::Bit32::Clear();
    }
  }
  argstrlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LenPayload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:demo.LenPayload)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string argStrList = 1;
      case 1: {
        if (tag == 10) {
         parse_argStrList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_argstrlist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->argstrlist(this->argstrlist_size() - 1).data(),
            this->argstrlist(this->argstrlist_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "argstrlist");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_argStrList;
        if (input->ExpectTag(18)) goto parse_argVarintMsg;
        break;
      }

      // optional .demo.VarintMsg argVarintMsg = 2;
      case 2: {
        if (tag == 18) {
         parse_argVarintMsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_argvarintmsg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_argBit64;
        break;
      }

      // optional .demo.Bit64 argBit64 = 3;
      case 3: {
        if (tag == 26) {
         parse_argBit64:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_argbit64()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_argBit32;
        break;
      }

      // optional .demo.Bit32 argBit32 = 4;
      case 4: {
        if (tag == 34) {
         parse_argBit32:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_argbit32()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:demo.LenPayload)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:demo.LenPayload)
  return false;
#undef DO_
}

void LenPayload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:demo.LenPayload)
  // repeated string argStrList = 1;
  for (int i = 0; i < this->argstrlist_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->argstrlist(i).data(), this->argstrlist(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "argstrlist");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->argstrlist(i), output);
  }

  // optional .demo.VarintMsg argVarintMsg = 2;
  if (has_argvarintmsg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->argvarintmsg(), output);
  }

  // optional .demo.Bit64 argBit64 = 3;
  if (has_argbit64()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->argbit64(), output);
  }

  // optional .demo.Bit32 argBit32 = 4;
  if (has_argbit32()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->argbit32(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:demo.LenPayload)
}

::google::protobuf::uint8* LenPayload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:demo.LenPayload)
  // repeated string argStrList = 1;
  for (int i = 0; i < this->argstrlist_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->argstrlist(i).data(), this->argstrlist(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "argstrlist");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->argstrlist(i), target);
  }

  // optional .demo.VarintMsg argVarintMsg = 2;
  if (has_argvarintmsg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->argvarintmsg(), target);
  }

  // optional .demo.Bit64 argBit64 = 3;
  if (has_argbit64()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->argbit64(), target);
  }

  // optional .demo.Bit32 argBit32 = 4;
  if (has_argbit32()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->argbit32(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:demo.LenPayload)
  return target;
}

int LenPayload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .demo.VarintMsg argVarintMsg = 2;
    if (has_argvarintmsg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->argvarintmsg());
    }

    // optional .demo.Bit64 argBit64 = 3;
    if (has_argbit64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->argbit64());
    }

    // optional .demo.Bit32 argBit32 = 4;
    if (has_argbit32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->argbit32());
    }

  }
  // repeated string argStrList = 1;
  total_size += 1 * this->argstrlist_size();
  for (int i = 0; i < this->argstrlist_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->argstrlist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LenPayload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LenPayload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LenPayload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LenPayload::MergeFrom(const LenPayload& from) {
  GOOGLE_CHECK_NE(&from, this);
  argstrlist_.MergeFrom(from.argstrlist_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_argvarintmsg()) {
      mutable_argvarintmsg()->::demo::VarintMsg::MergeFrom(from.argvarintmsg());
    }
    if (from.has_argbit64()) {
      mutable_argbit64()->::demo::Bit64::MergeFrom(from.argbit64());
    }
    if (from.has_argbit32()) {
      mutable_argbit32()->::demo::Bit32::MergeFrom(from.argbit32());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LenPayload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LenPayload::CopyFrom(const LenPayload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LenPayload::IsInitialized() const {

  if (has_argvarintmsg()) {
    if (!this->argvarintmsg().IsInitialized()) return false;
  }
  if (has_argbit64()) {
    if (!this->argbit64().IsInitialized()) return false;
  }
  if (has_argbit32()) {
    if (!this->argbit32().IsInitialized()) return false;
  }
  return true;
}

void LenPayload::Swap(LenPayload* other) {
  if (other != this) {
    argstrlist_.Swap(&other->argstrlist_);
    std::swap(argvarintmsg_, other->argvarintmsg_);
    std::swap(argbit64_, other->argbit64_);
    std::swap(argbit32_, other->argbit32_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LenPayload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LenPayload_descriptor_;
  metadata.reflection = LenPayload_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace demo

// @@protoc_insertion_point(global_scope)
